<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GIS WASM åæ ‡è½¬æ¢æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .input-group { margin: 10px 0; }
        label { display: inline-block; width: 120px; }
        input { padding: 5px; margin: 5px; }
        button { padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer; }
        .result { margin: 20px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; }
        .error { background: #ffebee; color: #c62828; }
        .success { background: #e8f5e8; color: #2e7d32; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GIS WASM åæ ‡è½¬æ¢æµ‹è¯•</h1>
        
        <div class="input-group">
            <label>ç»åº¦ (Longitude):</label>
            <input type="number" id="longitude" value="116.404" step="any">
        </div>
        
        <div class="input-group">
            <label>çº¬åº¦ (Latitude):</label>
            <input type="number" id="latitude" value="39.915" step="any">
        </div>
        
        <div class="input-group">
            <label>æºåæ ‡ç³» EPSG:</label>
            <select id="fromEpsg">
                <option value="4326">4326 (WGS84 ç»çº¬åº¦)</option>
                <option value="3857">3857 (Web Mercator)</option>
                <option value="4258">4258 (ETRS89)</option>
                <option value="4269">4269 (NAD83)</option>
                <option value="4490">4490 (CGCS2000)</option>
            </select>
        </div>
        
        <div class="input-group">
            <label>ç›®æ ‡åæ ‡ç³» EPSG:</label>
            <select id="toEpsg">
                <option value="3857">3857 (Web Mercator)</option>
                <option value="4326">4326 (WGS84 ç»çº¬åº¦)</option>
                <option value="4258">4258 (ETRS89)</option>
                <option value="4269">4269 (NAD83)</option>
                <option value="4490">4490 (CGCS2000)</option>
            </select>
        </div>
        
        <button onclick="transformCoordinate()">è½¬æ¢åæ ‡</button>
        <button onclick="runTests()">è¿è¡Œæµ‹è¯•ç”¨ä¾‹</button>
        
        <div id="result" class="result" style="display: none;"></div>
        
        <h2>é¢„å®šä¹‰æµ‹è¯•ç”¨ä¾‹</h2>
        <p>ç‚¹å‡»"è¿è¡Œæµ‹è¯•ç”¨ä¾‹"å°†æµ‹è¯•ä»¥ä¸‹è½¬æ¢ï¼š</p>
        <ul>
            <li>åŒ—äº¬å¤©å®‰é—¨: WGS84 (116.404, 39.915) â†’ Web Mercator</li>
            <li>ä¸Šæµ·ä¸œæ–¹æ˜ç : WGS84 (121.506, 31.245) â†’ Web Mercator</li>
            <li>Web Mercator â†’ WGS84 åå‘è½¬æ¢</li>
            <li>GeoJSON é¢ç§¯è®¡ç®—ï¼ˆæ¥è‡ª aaa.geojsonï¼Œç®€åŒ–ï¼šæŠ•å½±åˆ° Web Mercator åé‹å¸¦å…¬å¼ï¼‰</li>
            <li>ä¸¤ç‚¹é—´å“ˆå¼—è¾›è·ç¦»ï¼ˆåŒ—äº¬ â†” ä¸Šæµ·ï¼‰</li>
        </ul>
    </div>

    <script type="module">
        import init, { transform_point, JsPoint, haversine_distance, bbox } from './pkg/GIS_Wasm_Algorithm.js';
        
        let wasm;
        
        async function run() {
            wasm = await init();
            console.log('WASM æ¨¡å—åŠ è½½æˆåŠŸ');
            
            // ä½¿å…¨å±€å¯ç”¨
            window.transform_point = transform_point;
            window.JsPoint = JsPoint;
            window.haversine_distance = haversine_distance;
            window.bbox = bbox;
        }
        
        window.transformCoordinate = function() {
            if (!wasm) {
                showResult('WASM æ¨¡å—å°šæœªåŠ è½½å®Œæˆ', 'error');
                return;
            }
            
            const lon = parseFloat(document.getElementById('longitude').value);
            const lat = parseFloat(document.getElementById('latitude').value);
            const fromEpsg = parseInt(document.getElementById('fromEpsg').value);
            const toEpsg = parseInt(document.getElementById('toEpsg').value);
            
            try {
                const result = transform_point(lon, lat, fromEpsg, toEpsg);
                const resultText = `
                    <strong>è½¬æ¢æˆåŠŸ!</strong><br>
                    è¾“å…¥åæ ‡: (${lon}, ${lat}) EPSG:${fromEpsg}<br>
                    è¾“å‡ºåæ ‡: (${result.x.toFixed(6)}, ${result.y.toFixed(6)}, ${result.z.toFixed(6)}) EPSG:${toEpsg}
                `;
                showResult(resultText, 'success');
            } catch (error) {
                showResult(`è½¬æ¢å¤±è´¥: ${error}`, 'error');
            }
        };
        
        window.runTests = async function() {
            if (!wasm) {
                showResult('WASM æ¨¡å—å°šæœªåŠ è½½å®Œæˆ', 'error');
                return;
            }
            
            const testCases = [
                {
                    name: 'åŒ—äº¬å¤©å®‰é—¨ WGS84 â†’ Web Mercator',
                    lon: 116.404, lat: 39.915, from: 4326, to: 3857
                },
                {
                    name: 'ä¸Šæµ·ä¸œæ–¹æ˜ç  WGS84 â†’ Web Mercator',
                    lon: 121.506, lat: 31.245, from: 4326, to: 3857
                },
                {
                    name: 'Web Mercator â†’ WGS84 (åå‘è½¬æ¢)',
                    lon: 12958742.0, lat: 4825771.0, from: 3857, to: 4326
                }
            ];
            
            let results = '<strong>æµ‹è¯•ç»“æœ:</strong><br>';
            let passCount = 0;
            
            // æŠ•å½±è½¬æ¢ç”¨ä¾‹
            testCases.forEach((test) => {
                try {
                    const result = transform_point(test.lon, test.lat, test.from, test.to);
                    results += `âœ… ${test.name}: (${result.x.toFixed(6)}, ${result.y.toFixed(6)})<br>`;
                    passCount++;
                } catch (error) {
                    results += `âŒ ${test.name}: å¤±è´¥ - ${error}<br>`;
                }
            });

            results += `<br><strong>é€šè¿‡: ${passCount}/${testCases.length}</strong><br>`;

            // å“ˆå¼—è¾›è·ç¦»è®¡ç®—ï¼ˆåŒ—äº¬ â†” ä¸Šæµ·ï¼‰
            try {
                const dist = haversine_distance(116.404, 39.915, 121.506, 31.245);
                results += `ğŸ“ å“ˆå¼—è¾›è·ç¦»ï¼ˆåŒ—äº¬ â†” ä¸Šæµ·ï¼‰: ${(dist / 1000).toFixed(2)} km<br>`;
            } catch (error) {
                results += `âŒ å“ˆå¼—è¾›è·ç¦»è®¡ç®—å¤±è´¥: ${error}<br>`;
            }

            // ä» aaa.geojson è¯»å–å¹¶è®¡ç®—é¢ç§¯ï¼ˆç®€åŒ–ï¼šæŠ•å½±åˆ° Web Mercator åç”¨é‹å¸¦å…¬å¼æ±‚é¢ç§¯ï¼Œå•ä½ mÂ²ï¼‰
            try {
                const resp = await fetch('aaa.geojson');
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();

                // æå–å‡ ä½•
                let geom = null;
                if (data && data.type === 'FeatureCollection' && Array.isArray(data.features) && data.features.length > 0) {
                    geom = data.features[0].geometry;
                } else if (data && data.type === 'Feature' && data.geometry) {
                    geom = data.geometry;
                } else if (data && data.type && data.coordinates) {
                    geom = data; // å·²æ˜¯ Geometry
                }
                if (!geom) throw new Error('æ— æ³•ä» aaa.geojson æå–å‡ ä½• Geometry');

                // å·¥å…·å‡½æ•°ï¼šå»æ‰é—­åˆé‡å¤ç‚¹
                const cleanRing = (ring) => {
                    if (!ring || ring.length < 3) return ring || [];
                    const first = ring[0];
                    const last = ring[ring.length - 1];
                    if (first[0] === last[0] && first[1] === last[1]) return ring.slice(0, -1);
                    return ring;
                };

                // å·¥å…·å‡½æ•°ï¼šé‹å¸¦å…¬å¼é¢ç§¯ï¼ˆå·²åœ¨ç±³å•ä½åæ ‡ï¼‰
                const ringArea = (ring) => {
                    const r = cleanRing(ring);
                    let area = 0;
                    for (let i = 0, j = r.length - 1; i < r.length; j = i++) {
                        const [x1, y1] = r[j];
                        const [x2, y2] = r[i];
                        area += (x1 * y2 - x2 * y1);
                    }
                    return Math.abs(area) / 2;
                };

                // å°†ç»çº¬åº¦æŠ•å½±åˆ° Web Mercatorï¼ˆEPSG:3857ï¼‰
                const projRingTo3857 = (ringLngLat) => ringLngLat.map(([lon, lat]) => {
                    const p = transform_point(lon, lat, 4326, 3857);
                    return [p.x, p.y];
                });

                const areaPolygon3857 = (poly) => {
                    // poly: [outer, hole1, hole2, ...]
                    if (!Array.isArray(poly) || poly.length === 0) return 0;
                    const outer = projRingTo3857(poly[0]);
                    let area = ringArea(outer);
                    for (let i = 1; i < poly.length; i++) {
                        const hole = projRingTo3857(poly[i]);
                        area -= ringArea(hole);
                    }
                    return Math.max(area, 0);
                };

                let areaM2 = 0;
                if (geom.type === 'Polygon') {
                    areaM2 = areaPolygon3857(geom.coordinates);
                } else if (geom.type === 'MultiPolygon') {
                    for (const poly of geom.coordinates) {
                        areaM2 += areaPolygon3857(poly);
                    }
                } else {
                    throw new Error(`æš‚ä¸æ”¯æŒçš„å‡ ä½•ç±»å‹: ${geom.type}`);
                }

                results += `ğŸ“ GeoJSON é¢ç§¯ï¼ˆé¢ç§¯è®¡ç®—ï¼ŒWeb Mercator è¿‘ä¼¼ï¼‰: ${areaM2.toFixed(2)} mÂ²<br>`;

                // è®¡ç®—å¹¶æ˜¾ç¤º bboxï¼ˆç›´æ¥åŸºäº GeoJSON åŸå§‹åæ ‡ç³»ï¼‰
                try {
                    const box = bbox(geom);
                    const arr = Array.from(box);
                    results += `ğŸ§­ BBox: [${arr.map(v => Number(v).toFixed(6)).join(', ')}]` + '<br>';
                } catch (e) {
                    results += `âŒ BBox è®¡ç®—å¤±è´¥: ${e}<br>`;
                }
            } catch (error) {
                results += `âŒ GeoJSON é¢ç§¯è®¡ç®—å¤±è´¥: ${error}<br>`;
            }
            
            showResult(results, passCount === testCases.length ? 'success' : 'error');
        };
        
        function showResult(text, type) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = text;
            resultDiv.className = 'result ' + type;
            resultDiv.style.display = 'block';
        }
        
        run();
    </script>
</body>
</html>
